{"meta":{"title":"原始计划","subtitle":"黎明之前...","description":"生活从来不欺骗任何一个人,因为它根本谁都不认识.","author":"wzygene","url":"https://wzygene.github.io"},"pages":[],"posts":[{"title":"jsonp跨域原理浅析","slug":"jsonp跨域原理浅析","date":"2016-02-17T10:35:25.000Z","updated":"2017-09-17T14:43:50.147Z","comments":true,"path":"2016/02/17/jsonp跨域原理浅析/","link":"","permalink":"https://wzygene.github.io/2016/02/17/jsonp跨域原理浅析/","excerpt":"","text":"我们实际开发中，经常遇到这样一种情况，就是需要到别人的网站上去请求一些数据，就是所谓的跨域请求数据。跨域的具体解释请查看这篇博文：什么是跨域？先了解域名机制。但是因为一些安全性的问题，浏览器有一种跨域保护机制，我们在跨域请求数据的时候，浏览器会进行阻止。这样,即使我们确认没有安全问题的情况下，也不能请求别人的数据了。我们是不是应该有一种机制可以获取到别的网站的数据呢？ 其实解决跨域请求数据的方式是很多的：jsonp、反向代理、CORS、通过 document.domain 跨子域。。。 其中比较常用的就是 jsonp 的方式。这里，就来浅析一下 jsonp 的内部原理。 我们从后台获取的数据往往使用的是 ajax 的方式，但是因为浏览器的跨域保护机制的存在，ajax 不允许跨域获取数据。正规的渠道行不通，我们就要通过别的办法来解决问题（至少的技术领域，必须这样做）。接下来用一句话概括 jsonp 的实现原理： jsonp 就是利用 script 标签的 src 属性去发送请求，来获取数据。 用一个小 demo 来解释这个具体操作： 首先，用 Apache 搭建两个虚拟主机，在第一个虚拟主机的域名就设置为 localhost，对应的文件夹下边创建一个 date.php 文件，内容为：123&lt;?php echo 'var n = 123;';?&gt; 在二个虚拟主机对应的文件夹下边创建一个 test.html 文件，内容为：12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;jsonp demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 接下来，使用 script 标签去获取 data.php 文件的数据，将下边这行代码插入到 test.html 的 head 标签中：1&lt;script src=\"http://localhost/data.php\"&gt;&lt;/script&gt; 我们，打开 test.html 文件，在控制台的 Network 窗口下就可以看到这里已经获取到了返回来的数据： 我们在 test.html 中打印一下n123&lt;script&gt; console.log(n);&lt;/script&gt; 控制台中，不出意外地打印出了：123 这里有很不好的一点，就是这样的数据请求方式数据同步的，这样我们的程序和可能就是因为网络等一些外部原因产生阻塞，造成很不好的体验，所以我们把 async 属性加到请求数据的 script 标签中，使数据请求方式变成异步的：1&lt;script async src=\"http://doc.studyit.com/data.php?flag=1\"&gt;&lt;/script&gt; 但是，这个时候的控制台报错了： Uncaught ReferenceError: n is not defined 因为请求方式变成了异步的，而请求数据是要花费时间的，所以，打印 n 的操作在数据返回来之前就执行了。结果就是，n 变成了 undefined。 同步会阻塞程序，使体验变差；异步操作，数据的使用发生在获取之前，造成代码错误。。。我们应该怎么解决呢？ 回调函数！！！ 使用回调函数，就可以完美地解决这个问题。 我们在 test.html 中声明一个函数：123function hello(data)&#123; console.log(data);&#125; 然后在 data.php 文件中执行这个函数1234&lt;?php // echo 'var n = 123;'; echo 'hello(123)';?&gt; 这样，再打开 test.html 文件就能正常打印出 123 了。 但是，上面的代码都太生硬了，很死板，不够灵活。所以，采用一个比较方便的做法就是：动态创建 script 标签，然后通过标签的 src 属性发送跨域请求，并且可以携带参数,后台响应的内容是js代码（函数调用） 前端代码：123456789 // 创建script标签var script = document.createElement('script');// 携带参数：flag是一个普通参数，callback是回调函数的函数名var param = '?flag=123&amp;callback=hello';// 利用src属性发送请求script.src = 'http://localhost/data.php'+param;// 将 script 标签放到 head 标签中var head = document.getElementsByTagName('head')[0];head.appendChild(script); 服务端代码：12345678910// 获取flag数据$flag = $_GET['flag'];// 获取回调函数$callback = $_GET['callback'];// 创建一个数组$arr = array('name'=&gt;'xiaoming','age'=&gt;'12','flag'=&gt;$flag);// 把数组换换成字符串$str = json_encode($arr);// 调用回调函数，打印数据echo $callback.'('.$str.')'; 这样，代码运行完毕之后，在浏览器的控制台就打印出来如下的数据： jsonp 的基本原理其实就是这样。但是上边的代码看起来太 low 了。所以 jquery 以一种很优雅的方式对上边的代码进行了封装。 我们封装了一个函数：myAjax，基本模拟出了来 jquery 的 ajax 方法在用作跨域时的一些列操作：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 封装一个函数，模拟 $.ajax 跨域时的操作 function myAjax(obj)&#123; // 默认参数 var defaults = &#123; jsonp : 'callback' &#125; // 覆盖默认参数 for(var key in obj)&#123; defaults[key] = obj[key]; &#125; // 默认回调函数名称（这个函数名称非常个性，是jQuery拼接了一段随机数和当前时间作为了一个回调函数的函数名） var cbName = 'jQuery' + ('v1.11.1' + Math.random()).replace(/\\D/g,'') + '_' + new Date().getTime(); if(defaults.jsonpCallback)&#123; // 可以使用 jsonpCallback 自行定制回调函数名称 cbName = defaults.jsonpCallback; &#125; // 定义回调函数 window[cbName] = function(data)&#123; defaults.success(data); &#125; // 发送跨域请求 var script = document.createElement('script'); var param = ''; if(defaults.data)&#123; for(var key in defaults.data)&#123; param += key + '=' + defaults.data[key] + '&amp;'; &#125; &#125; script.src = defaults.url + '?' + param + defaults.jsonp + '=' + cbName; var head = document.getElementsByTagName('head')[0]; head.appendChild(script);&#125;// 发送跨域请求myAjax(&#123; url : 'http://doc.studyit.com/data.php', jsonp : 'abc', jsonpCallback : 'hello', data : &#123;flag:123&#125;, dataType : 'jsonp', success : function(data)&#123; console.log(data); &#125;&#125;); 这段代码执行完毕之后，打印的结果是: 这样我们就基本上模拟出了 jquery 封装的跨域操作。 跨域的请求方式还有很多，在这里就不一一赘述了。 荆轲刺秦王。","categories":[],"tags":[]},{"title":"浅聊原型链原理","slug":"浅聊原型链原理","date":"2015-11-27T03:44:06.000Z","updated":"2017-08-28T03:05:49.217Z","comments":true,"path":"2015/11/27/浅聊原型链原理/","link":"","permalink":"https://wzygene.github.io/2015/11/27/浅聊原型链原理/","excerpt":"","text":"javascript作为世界上最好的脚本语言，几乎已经是无所不能。而想要触及这门语言的灵魂，我们必须要搞明白prototype，也就是原型，可以说原型是javascript最为核心的一个概念。 每一个构造函数都有一个属性prototype,指向一个对象。当这个构造函数被new的时候，他的每一个实例的proto属性也都指向这个对象。 每一个函数都天生都有一个prototype属性，指向一个空对象，也就是说，我们不需要定义这个属性，任何一个函数，在他写出来的那一瞬间，就有了这个属性，这个属性对于函数本身而言，没有任何的意义。它存在的意义，就是为他创造的实例对象做指向。通俗地说，构造函数就是一个伟大的母亲，她自身出现的那一刻，就为自己将来的儿子们准备好了一盏之路的明灯–prototype。 例如：有一个函数叫 People ，这个函数的属性 prototype 指向了一个对象，叫做 People.prototype。 一天，这个函数实例化了一个对象，叫做 Jacob， 实例化这个对象的时候，他就有了一个与生俱来的属性，叫做proto，他看见实例化自己的构造函数People的 prototype 属性指向了 People.prototype， 随之就将自己的proto属性也指向了 People.prototype 这个对象 123456function People(name,age) &#123; this.name = name; this.age = age;&#125;var Jacob = new People(&quot;Jacob&quot;,20); 当这个代码写完的时候，在浏览器内部其实就做了如下的事情： people.prototype是people构造函数的”原型”(prototype),是 Jacob 的”原型对象”(proto). 这是很多js书上的原文表达的意思，最简明扼要地解释了原型的根本内容。 原型就是这样了，那它到底是用来干是什么的呢？这就得提到原型链了。 说原型链，其实就是在解释proto这个玩意的作用，接着上面的例子来说，当Jacob身上没有某个属性的时候，它会沿着proto指向去People.prototype身上寻找这个属性。当原型对象People.prototype身上也没有，这个时候注意了，People.prototype也是一个对象，所以，它也有自己的proto，这样，Jacob就会继续沿着People.prototype的proto指向继续去寻找。当出现一下两种情况的时候才会停止： * 在某一时刻，他找到了它想要的那个属性； * 它走到的原型链的末端 Object.prototype 这个过程，就是一个原型链查找的过程，这个过程中所经历的每个原型对象组合在一起，就是一条原型链。 原型链查找的作用非常强大，可以说这个机制是构成javascript这门语言其他各种机制的根基，所以，我们必须要清清楚楚地搞清楚个机制，这对我们理解一些javascript库和之后继承机制有决定性的作用。","categories":[],"tags":[]},{"title":"到底什么是构造函数","slug":"到底什么是构造函数","date":"2015-11-23T03:02:01.000Z","updated":"2017-08-31T13:58:15.927Z","comments":true,"path":"2015/11/23/到底什么是构造函数/","link":"","permalink":"https://wzygene.github.io/2015/11/23/到底什么是构造函数/","excerpt":"","text":"javascript是一门基于对象的语言，之所以是基于对象，而不是面向对象，是因为js这门语言没有类的概念，因此它的对象与基于类的语言中的对象有所不同。 我们可以把js中的对象想象成一组无序的散列表。比如下面这就是一个最简单的对象12345678var person = &#123; name:'小明', age:12, hobby:'王者农药', play:function()&#123; alert('来吧，我的亚瑟贼6！'); &#125;&#125; 在这个简单的对象里面定义了一个实体，他有自己的某些特征：name、age、hobby，这就是我们常说的属性，同时还有自己的一个行为：play王者农药，这就是我们常说的方法。 这是用字面量的方式创建的一个对象。我们还可以使用构造函数创建一个对象，但是构造函数是什么？如果仅仅将函数名首字母大写的函数理解为是构造函数。。。呵呵！ 要彻底理解构造函数，我们还是看看创建对象的演变过程吧，等这个故事讲完了，答案也就有了。 我们往往要创建大量的对象，而这些对象很多有相同的属性群和方法群，这样的对象要是全都用字面量的方式去创建，很麻烦，而且没必要，因为我们可以使用一个函数来模拟出一个工厂，专门用来创建一类对象，这就是所谓的工厂函数。请看下面的例子12345678910function createPerson(name,age,hobby)&#123; var person = &#123;&#125;; person.name = name; person.age = age; person.hobby = hobby; return person;&#125;var xiaoming = createPerson('xiaoming',12,'王者农药');var xiaohong = createPerson('xiaohong',14,'英雄联盟'); 使用这个函数，我们就可以创建一个 person 类型的对象，这个函数没别的功能，它只能：创建一个对象，赋予这个对象一定的属性，然后将这个对象返回。上述代码中， xiaoming 和xiaohong 就是用这个工程函数创建出来的两个有相同属性群的对象。 工程函数解决了创建多个相似对象的问题，但是它无法判定一个对象属于那种类型，这是个很麻烦的问题，但是随着js的发展，有一个新的模式出现了。那就是我们的主角：构造函数。先看一个构造函数的小例子1234567function Person(name,age,hobby)&#123; this.name = name, this.age = age, this.hobby = hobby&#125;var xiaoming = new Person('xiaoming',12,'王者农药');var xiaohong = new Person('xiaohong',14,'英雄联盟'); 上面这段代码就是典型的使用构造函数创建对象的过程。我们可以看到构造函数创建对象和工厂函数创建对象的几点不同之处： 1.函数体内部开始位置并没有创建对象； 2.直接将属性赋予了this对象； 3.函数结束的位置并没返回任何东西； 4.在调用函数的时候，在函数前面加了一个 new 操作符。 这几点不同之处就是理解构造函数的关键。 其实，一个函数能不能称之为构造函数，与它怎么定义没有半毛钱的关系，关键在于这个函数怎么调用。如果直接调用，或者作为一个对象的方法被调用，他都只是一个普通的函数。但是如果使用 new 操作符去调用一个函数，那就不一样了，这个 new 操作符会悄悄地做一些事情，而被调用的函数就是因为 new 操作符做的这些事情，被抬到了一个新的高度，然后被赋予一个新的称呼：构造函数。 那么，new 操作符到底做什么事情呢？其实就是4个步骤： 1.创建一个新对象； 2.将构造函数的上下文设置成这个对象（因此this就指向了这个对象）； 3.依次执行构造函数中的代码（也就是给这个对象添加属性）； 4.返回这个新对象。 所以，在 Person 函数中，我们没有看到创建对象，也没有看到函数返回任何东西，但是最终一个对象被创建了出来，就是因为这些工作都被 new 操作符隐式地完成了。 这个时候，我们别忘了之前的那个问题：怎么判断一个对象的类型？使用构造函数创建一个对象之后，这个对象就会有一个constructor属性，通过这个属性我们就能判断这个对象是什么类型了。在之前代码的基础上执行下面这句代码1console.log(xiaoming.constructor == Person); 没什么好怀疑的，打印的结果就是 true。 我们现在该思考一个问题了，构造函数中并没有给this对象赋值一个 constructor 的属性啊，它是从哪跑粗来的？ 答案是：原型。 原型是什么？呵呵，荆轲刺秦王！！！","categories":[],"tags":[]},{"title":"函数执行环境及变量作用域","slug":"函数执行环境及变量作用域","date":"2015-06-28T12:12:14.000Z","updated":"2017-08-31T16:54:13.675Z","comments":true,"path":"2015/06/28/函数执行环境及变量作用域/","link":"","permalink":"https://wzygene.github.io/2015/06/28/函数执行环境及变量作用域/","excerpt":"","text":"执行环境是javascript中最为重要的一个概念。执行环境定义了变量或者函数有权访问的其他数据，决定了他们各自的行为。 在每一种编程语言中，都有所谓的执行环境的概念，但是很少有人重视这个概念，因为每个程序员都对执行环境都有自己感性的认识：自己内部的数据和外部的全局变量都是可以使用的。 这么理解在大多数时间内是没有太大问题的。但是要想深入理解这门语言，应该对这个概念有更加清晰的认识，做到知其然，并知其所以然。 每一个执行环境中都有一个变量对象，这个对象里边存放了当前环境中所有的变量和方法。 最外层的执行环境，也叫全局执行环境，通俗一点说，在浏览器中，就是我们常常说的window对象，因此全局环境中所有的变量和函数都是作为window对象的属性和方法而存在的。 每一个函数都是一个独立的执行环境。js语言有一个管理执行环境的机制：当程序执行到一个函数时，这个函数将被推进一个环境栈中，等到函数执行结束的时候，环境栈会将这个函数弹出，并删除这个函数的便能量对象，然后将环境栈的控制权交还给之前的执行环境。而window对象会直到应用程序退出（例如关闭网页或者浏览器）的时候才被删除数据。 当代码在一个环境中执行的时候，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境能够访问的变量和函数进行有序的访问。作用域链的第一个变量对象，就是当前执行环境的变量对象。作用域链中的下一个变量对象来自外部环境，而再下一个变量对象来自下一个外部环境。就这样，一直延伸到全局环境中。所以，全局环境的变量对象是每个作用域链的最后一个对象。 标识符解析是沿着作用域链一级一级地搜索标识符的过程。 这个解析的过程始终都是从第一个变量对象开始，逐级向外延伸，直到找到标识符为止（如果找到最后还没有找到，那就会报错）。下边代码是一个三级作用域链的小例子：1234567var Country = 'China';function province()&#123; var province = 'beijing'; function county ()&#123; var county = 'changping'; &#125;&#125; 在上变的代码中： + 函数 county 中，能访问到 county，province，Country 这三个变量； + 函数 province 中，能访问到 province，Country 这两个变量； + 在全局中，只能访问到 Country 这一个变量。 函数的作用域链如下图： 作用域链的箭头经过的地方，都是该函数的有效作用域，且查找顺序和作用域链经过的区域顺序一致。 这里有一点需要注意一下：函数参数也当做变量来对待，因此访问规则与执行环境中其他变量相同。","categories":[],"tags":[]},{"title":"with函数--一个不错的小工具","slug":"with函数-一个不错的小工具","date":"2015-06-18T08:32:15.000Z","updated":"2017-08-28T13:50:08.920Z","comments":true,"path":"2015/06/18/with函数-一个不错的小工具/","link":"","permalink":"https://wzygene.github.io/2015/06/18/with函数-一个不错的小工具/","excerpt":"","text":"with函数，也叫做with语句。是一个拓展作用域链的小工具。他可以通过传递 “参数” 的方式，简化我们的代码量。请看下边的例子：12345678910var date = new Date();function getDate() &#123; var year = date.getFullYear(); var month = date.getMonth()+1; var day = date.getDate(); return year+' '+month+' '+day;&#125;var currentDate = getDate();console.log(currentDate); 上面的这段代码的，首先通过构造函数的方式创建了一个日期对象，然后定义了一个函数，在函数中分别获取了当前的年、月、日，最后将它们拼接成一个字符串并返回。 可以看到，我们在函数getDate中，每次获取年月日，都要通过事先创建的日期对象来调用其内部方法来实现。这是因为直接调用方法的话，在当前的作用域链中找不到对应的方法。 但是，通过with函数就可以避免频繁使用对象，我们可将对象作为参数传到with函数中去，从而扩展作用域链（将date对象加入到自己的作用域链中），然后就可以直接调用方法了。改进的代码如下：1234567891011var date = new Date();function getDate() &#123; with(date)&#123; var year = getFullYear(); var month = getMonth()+1; var day = getDate(); &#125; return year+' '+month+' '+day;&#125;var currentDate = getDate();console.log(currentDate); 这段代码和上面那段代码，最终的执行结果是一样的。","categories":[],"tags":[]}]}