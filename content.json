{"meta":{"title":"原始计划","subtitle":"黎明之前...","description":null,"author":"wzygene","url":"https://wzygene.github.io"},"pages":[],"posts":[{"title":"js实现继承的几种方式","slug":"js实现继承的几种方式","date":"2017-10-09T02:34:20.094Z","updated":"2017-10-09T03:09:03.648Z","comments":true,"path":"2017/10/09/js实现继承的几种方式/","link":"","permalink":"https://wzygene.github.io/2017/10/09/js实现继承的几种方式/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"jquery底层实现以及插件扩展原理","slug":"jquery底层实现以及插件扩展原理","date":"2017-02-18T07:38:36.000Z","updated":"2017-10-09T03:08:52.194Z","comments":true,"path":"2017/02/18/jquery底层实现以及插件扩展原理/","link":"","permalink":"https://wzygene.github.io/2017/02/18/jquery底层实现以及插件扩展原理/","excerpt":"","text":"jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 这是一个所有的前端工程师都使用过的 js 库，他的功能很强大，代码设计很优雅。。。所以我们这里就来探究一下 jquery 底层实现的原理。 通过$符获取元素jquery 获取 DOM 元素的方式是 $(‘选择器’)，以标签选择器为例，看下面这段代码：123456789101112131415161718(function (window) &#123; function $(selector) &#123; // 调用 $ 不需要再手动 new 了，因为在这个函数内部已经帮我们 new 了 return new init(selector); &#125; // 这种方式创建出的就是一个伪数组 function init(selector) &#123; // 这里只是模拟了通过标签名获取元素 var element = document.getElementsByTagName(selector); this.length = element.length; for (var i = 0; i &lt; element.length; i++) &#123; this[i] = element[i]; &#125; &#125; window.$ = $;&#125;)(window); 这段代码就是 jquery 获取 DOM 元素的基本思路，在这样的一个自执行函数后边，我们就可以使用 $(‘标签名’)，来获取页面中的元素，然后进行一些操作，通过 id、class 等其他方式获取元素的基本思想也就是这样，只要进行一些相对应的判断就可以了，就不一一赘述了。 一些常用的内置方法实现原理假如页面中有这样的一些元素：1234567&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;aaa&lt;/p&gt;&lt;p&gt;bbb&lt;/p&gt;&lt;p&gt;ccc&lt;/p&gt; 可以使用 jquery 的 css 的方法对这些元素进行一些样式设置：12345$('div').css('width', '100px');$('div').css('height', '100px');$('div').css('backgroundColor', 'red');$('p').css('color','blue'); 然后页面上就会出现这样的效果； 这个 css 方法的实现其实也很朴素，其基本的原理就是以下的这样一段代码：123456init.prototype.css = function (attr, val) &#123; // 访问 DOM 元素 for (var i = 0; i &lt; this.length; i++) &#123; this[i].style[attr] = val; &#125;&#125; 就是在 init 函数的原型对象上面添加了一个 css 方法，用来设置 DOM 元素的样式。 链式调用jquery 的方法都可以链式调用，比如上面设置样式的那段代码可以写成这样：123$('div').css('width', '100px').css('height', '100px').css('backgroundColor', 'red');$('p').css('color','blue'); 最终显示的效果还是一样的。链式调用的原理极其简单，因为可以调用方法的都是对象，一个方法之后紧接着又调用了一个方法，说明之前那个方法返回了一个对象，返回的是哪个对象呢？就是当前对象 this。以上面的 css 方法为例，改进后的方法就是:1234567init.prototype.css = function (attr, val) &#123; // 访问 DOM 元素 for (var i = 0; i &lt; this.length; i++) &#123; this[i].style[attr] = val; &#125; return this;&#125; 插件扩展原理jquery 诞生以来，程序员们基于 jquery 扩展的插件不计其数。而扩展插件的第一步操作都是1$.fn.xxx = xx; 是不是有点像是在原型对象上添加方法的感觉？其实，$.fn 就是 init.prototype，因为在 jquery 库中，有这样的一个操作：1$.fn = init.prototype; 因为，init 是内部函数，外部作用域是不能直接调用它的，在外部只能调用被暴露出来的 $ 函数。所以，jquery 内部自己扩展的方法可以写在 init.prototype 对象上，也可以写在 $.fn 对象上。但是在外部基于 jquery 库扩展的插件就只能使用 $.fn 这个接口了。比如，我们扩展一个很简单的插件：123456$.fn.attr = function (attr, val) &#123; for (var i = 0; i &lt; this.length; i++) &#123; this[i].setAttribute(attr,val); &#125; return this;&#125; 这个插件是用来设置一些自定义属性的，并且它也保证了链式调用，使用一下这个插件：1$('p').attr('foo','bar').attr('abc','haha').css('color','blue'); 审查元素之后可以看到： 自定义属性已经添加到元素中去了。 一次性扩展多个方法如果我们想要一次性扩展多个方法，有一个比较简单的方式，就是使用extend 方法，这是 jquery 内部封装的一个扩展插件的接口，基本实现思路是：12345init.prototype.extend = function (obj) &#123; for (var key in obj)&#123; this[key] = obj[key]; &#125;&#125; 这个方法可以用来扩展属性，也可以用来扩展方法：123456$.fn.extend(&#123; foo: 'bar', f: function () &#123; console.log(this); &#125;&#125;) 这样，就在 init 的原型上扩展了一个叫做 foo 的属性和一个叫做 f 的方法。 这里只是介绍了 jquery 的一些小特性，他还有很多很有创造性的设计思路，之后慢慢介绍。 荆轲刺秦王。","categories":[],"tags":[{"name":"JavaScript随笔","slug":"JavaScript随笔","permalink":"https://wzygene.github.io/tags/JavaScript随笔/"}]},{"title":"jsonp跨域原理浅析","slug":"jsonp跨域原理浅析","date":"2017-02-17T10:35:25.000Z","updated":"2017-10-09T03:09:11.537Z","comments":true,"path":"2017/02/17/jsonp跨域原理浅析/","link":"","permalink":"https://wzygene.github.io/2017/02/17/jsonp跨域原理浅析/","excerpt":"","text":"我们实际开发中，经常遇到这样一种情况，就是需要到别人的网站上去请求一些数据，就是所谓的跨域请求数据。跨域的具体解释请查看这篇博文：什么是跨域？先了解域名机制。但是因为一些安全性的问题，浏览器有一种跨域保护机制，我们在跨域请求数据的时候，浏览器会进行阻止。这样,即使我们确认没有安全问题的情况下，也不能请求别人的数据了。我们是不是应该有一种机制可以获取到别的网站的数据呢？ 其实解决跨域请求数据的方式是很多的：jsonp、反向代理、CORS、通过 document.domain 跨子域。。。 其中比较常用的就是 jsonp 的方式。这里，就来浅析一下 jsonp 的内部原理。 我们从后台获取的数据往往使用的是 ajax 的方式，但是因为浏览器的跨域保护机制的存在，ajax 不允许跨域获取数据。正规的渠道行不通，我们就要通过别的办法来解决问题（至少的技术领域，必须这样做）。办法就是：我们可以找一些具备请求跨域资源的标签来请求跨域的数据，这样的标签有：img，link，video，audio，script。在这里，我们获取到数据主要是用来进行js操作的，但是前面几种标签请求到的数据都不能做js操作。所以，完成任务的标签就只有script了。 用一句话概括 jsonp 的实现原理： jsonp 就是利用 script 标签的 src 属性去发送请求，来获取数据。 用一个小 demo 来解释这个具体操作： 首先，用 Apache 搭建两个虚拟主机，在第一个虚拟主机的域名就设置为 localhost，对应的文件夹下边创建一个 date.php 文件，内容为：123&lt;?php echo 'var n = 123;';?&gt; 在二个虚拟主机对应的文件夹下边创建一个 test.html 文件，内容为：12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;jsonp demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 接下来，使用 script 标签去获取 data.php 文件的数据，将下边这行代码插入到 test.html 的 head 标签中：1&lt;script src=\"http://localhost/data.php\"&gt;&lt;/script&gt; 我们打开 test.html 文件，在控制台的 Network 窗口下就可以看到这里已经获取到了返回来的数据： 我们在 test.html 中打印一下n123&lt;script&gt; console.log(n);&lt;/script&gt; 控制台中，不出意外地打印出了：123 这里有很不好的一点，就是这样的数据请求方式数据同步的，这样我们的程序和可能就是因为网络等一些外部原因产生阻塞，造成很不好的体验，所以我们把 async 属性加到请求数据的 script 标签中，使数据请求方式变成异步的：1&lt;script async src=\"http://doc.studyit.com/data.php?flag=1\"&gt;&lt;/script&gt; 但是，这个时候的控制台报错了： Uncaught ReferenceError: n is not defined 因为请求方式变成了异步的，而请求数据是要花费时间的，所以，打印 n 的操作在数据返回来之前就执行了。结果就是，n 变成了 undefined。 同步会阻塞程序，使体验变差；异步操作，数据的使用发生在获取之前，造成代码错误。。。我们应该怎么解决呢？ 回调函数！！！ 使用回调函数，就可以完美地解决这个问题。 我们在 test.html 中声明一个函数：123function hello(data)&#123; console.log(data);&#125; 然后在 data.php 文件中执行这个函数1234&lt;?php // echo 'var n = 123;'; echo 'hello(123)';?&gt; 这样，再打开 test.html 文件就能正常打印出 123 了。 但是，上面的代码都太生硬了，很死板，不够灵活。所以，采用一个比较方便的做法就是：动态创建 script 标签，然后通过标签的 src 属性发送跨域请求，并且可以携带参数,后台响应的内容是js代码（函数调用） 前端代码：123456789 // 创建script标签var script = document.createElement('script');// 携带参数：flag是一个普通参数，callback是回调函数的函数名var param = '?flag=123&amp;callback=hello';// 利用src属性发送请求script.src = 'http://localhost/data.php'+param;// 将 script 标签放到 head 标签中var head = document.getElementsByTagName('head')[0];head.appendChild(script); 服务端代码：12345678910// 获取flag数据$flag = $_GET['flag'];// 获取回调函数$callback = $_GET['callback'];// 创建一个数组$arr = array('name'=&gt;'xiaoming','age'=&gt;'12','flag'=&gt;$flag);// 把数组换成字符串$str = json_encode($arr);// 调用回调函数，打印数据echo $callback.'('.$str.')'; 这样，代码运行完毕之后，在浏览器的控制台就打印出来如下的数据： jsonp 的基本原理其实就是这样。但是上边的代码看起来太 low 了。所以 jquery 以一种很优雅的方式对上边的代码进行了封装。 我们封装了一个函数：myAjax，基本模拟出了来 jquery 的 ajax 方法在用作跨域时的一些列操作：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 封装一个函数，模拟 $.ajax 跨域时的操作 function myAjax(obj)&#123; // 默认参数 var defaults = &#123; jsonp : 'callback' &#125; // 覆盖默认参数 for(var key in obj)&#123; defaults[key] = obj[key]; &#125; // 默认回调函数名称（这个函数名称非常个性，是jQuery拼接了一段随机数和当前时间作为了一个回调函数的函数名） var cbName = 'jQuery' + ('v1.11.1' + Math.random()).replace(/\\D/g,'') + '_' + new Date().getTime(); if(defaults.jsonpCallback)&#123; // 可以使用 jsonpCallback 自行定制回调函数名称 cbName = defaults.jsonpCallback; &#125; // 定义回调函数 window[cbName] = function(data)&#123; defaults.success(data); &#125; // 发送跨域请求 var script = document.createElement('script'); var param = ''; if(defaults.data)&#123; for(var key in defaults.data)&#123; param += key + '=' + defaults.data[key] + '&amp;'; &#125; &#125; script.src = defaults.url + '?' + param + defaults.jsonp + '=' + cbName; var head = document.getElementsByTagName('head')[0]; head.appendChild(script);&#125;// 发送跨域请求myAjax(&#123; url : 'http://doc.studyit.com/data.php', jsonp : 'abc', jsonpCallback : 'hello', data : &#123;flag:123&#125;, dataType : 'jsonp', success : function(data)&#123; console.log(data); &#125;&#125;); 这段代码执行完毕之后，打印的结果是: 这样我们就基本上模拟出了 jquery 封装的跨域操作。 需要解释一下这个方法的一些内部细节： 为什么要设置 dataType：jsonp？必须要明确一点：jsonp不是ajax，他们只是在调用的时候有很多的相似之处，并且jquery库把他们都封装在了$.ajax方法中，但是他们的本质是完全不样的。 把dataType设置为jsonp之后,jqury对象的ajax方法底层就不再是去创建一个XMLHttpRequest对象了，而是去创建一个script标签，然后用script标签去发送请求。 所以说，ajax和jsonp的区别不在于是否跨域，其实通过服务器的反向代理的方式，ajax也可以实现跨域请求数据，而jsonp本身也并不排斥同源的数据。 jsonp是一种方式或者说非强制性协议，如同ajax一样，它不一定非要使用json对象来传递数据，如果你愿意，使用字符串，xml都可以。 如果们使用script标签向服务器发送请求，那么我们应该怎样接受服务器返回的数据？这个问题很重要。其实答案很简单：当我们用script标签发送了请求，服务器返回了数据，客户端浏览器会直接用javascript的方式去解析服务器返回的数据。因为请求是用script标签发送出去的，所以浏览器会用js的解析引擎去解析数据。 为什么只能解决get方式的跨域?很简单，因为jsonp就是使用script标签发送请求，而script标签中的src发送的请求都是get请求 用最简单的方式描述jsonp:客户端给服务端传递一个回调函数，服务端返回的是一个回调函数的调用，并且将数据放在回调函数里边作为参数传递过来。","categories":[],"tags":[{"name":"ajax小思考","slug":"ajax小思考","permalink":"https://wzygene.github.io/tags/ajax小思考/"}]},{"title":"Ajax的底层实现机制","slug":"Ajax的底层实现机制","date":"2017-01-29T03:06:53.000Z","updated":"2017-10-09T03:57:20.686Z","comments":true,"path":"2017/01/29/Ajax的底层实现机制/","link":"","permalink":"https://wzygene.github.io/2017/01/29/Ajax的底层实现机制/","excerpt":"","text":"AJAX 即 “Asynchronous Javascript And XML”（异步Javascript和XML），是指一种将创建交互式网页应用的网页开发技术。他最大的价值在于：它无需加载整个页面，就可以实现部分页面数据的更新。 Ajax并非是一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。 使用CSS和HTML来表示。 使用DOM模型来交互和动态显示。 使用XMLHttpRequest来和服务器进行异步通信（核心）。 使用javascript来绑定和调用。 Ajax原理和XMLHttpRequest对象Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。 XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。 所以我们要从XMLHttpRequest说起，来看看它的工作原理。 要先了解一下MLHttpRequest这个对象的属性。它的属性有： onreadystatechange 每次状态改变所触发事件的事件处理程序。 readyState 对象状态值 0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法） 1 (初始化) 对象已建立，尚未调用send方法 2 (发送数据) send方法已调用，但是当前的状态及http头未知 3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误， 4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据 status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪） responseText 从服务器进程返回数据的字符串形式。 responseXML 从服务器进程返回的DOM兼容的文档数据对象。 statusText 伴随状态码的字符串信息 Ajax请求发送的全过程12345678910111213141516171819202122// 创建一个XMLHttpRequest对象var xhr = new XMLHttpRequest();// 请求行xhr.open('method'，'url',isAsync);// 请求头xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');// 请求主体（这里的参数是要传递的数据）xhr.send();// 发送请求之后，要及时处理返回的数据xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; // 这个时候代表通讯完成了 if (xhr.status == 200) &#123; // 状态码是200 表示数据接收成功 // 响应头里面所有的响应信息 console.log(xhr.getAllResponseHeaders()); // 打印响应头里面某一个默认信息 使用xhr对象的 getResponseHeader 方法 console.log(xhr.getResponseHeader('content-type')); &#125; &#125;&#125; 这就是Ajax发送请求和处理响应的基本过程，但是原生的代码显得很繁琐，很low。 所以，jQuery已经使用一种很优雅的方式封装了 $.ajax 方法，下面这段代码基本上模拟出了这个方法的基本思想：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 声明一个全局变量window.$ = &#123;&#125;;// 在$对象里面声明一个属性 指向一个叫做 ajax 的函数$.ajax = function (options) &#123; // 实现代码 // options对象是用来传参数的 if(!options || typeof options != 'object') &#123; return false; &#125; // 设置默认参数 var type = options.type != 'post'?'get':'post'; // 只要不是post，就默认是get var url = options.url || location.pathname; var async = options.async !== false ? true : false ; var data = typeof options.data == 'object' ? options.data: &#123;&#125;; // 发送的数据需要键值对的字符串格式 转换一下 转换的形式为： key=value&amp;a=b var dataString = ''; for(var key in data)&#123; dataString += key+'='+data[key]+'&amp;'; &#125; // 如果dataString存在，把最后一个多出来的 '&amp;' 截掉 dataString = dataString &amp;&amp; dataString.slice(0,-1); // ajax 编程 var xhr = new XMLHttpRequest(); // 请求处理 xhr.open(type,type=='get'?url+'?'+dataString:url,async); if(type == 'post')&#123; xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); &#125; xhr.send(type=='get'?null:dataString); //响应处理 xhr.onreadystatechange = function () &#123; if(xhr.readyState == 4)&#123; // 通讯完成 if(xhr.status == 200)&#123; // 成功 // 获取数据 需要和后台的数据格式对应 // 前后端开发的约定：由Content-Type内容的类型来决定 // 如果 Content-Type 的内容中包含 xml 就返回xml // 如果 Content-Type 的内容中包含 json 就返回json var ct = xhr.getResponseHeader('Content-Type'); var result = null; if(ct.indexOf('xml')&gt;-1)&#123; result = xhr.responseXML; &#125; else if(ct.indexOf('json')&gt;-1)&#123; var jsonString = xhr.responseText; result = jsonString &amp;&amp; JSON.parse(jsonString); &#125;else &#123; result = xhr.responseText &#125; // 获取到的数据要给成功的业务用，调用成功回调函数 options.success &amp;&amp; options.success(result); &#125; else &#123; // 失败 var info = &#123;status:xhr.status,statusText:xhr.statusText&#125;; options.error &amp;&amp; options.error(); &#125; &#125; &#125;&#125; 这就是$.ajax方法的基本封装思路。","categories":[],"tags":[{"name":"ajax小思考","slug":"ajax小思考","permalink":"https://wzygene.github.io/tags/ajax小思考/"}]},{"title":"同源与跨域","slug":"同源与跨域","date":"2017-01-26T03:37:24.000Z","updated":"2017-10-09T03:08:38.464Z","comments":true,"path":"2017/01/26/同源与跨域/","link":"","permalink":"https://wzygene.github.io/2017/01/26/同源与跨域/","excerpt":"","text":"什么是同源策略？ 是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。 同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。当一个浏览器的两个tab页中分别打开来 百度和谷歌的页面当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。[1]如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。 限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。一个源指的是主机名、协议和端口号的组合，必须相同 跨域通信的几种方式 JSONPHashpostMessageWebSocketCORSJSONP原理基本原理：利用script标签的异步加载特性实现给服务端传一个回调函数，服务器返回一个传递过去的回调函数名称的JS代码","categories":[],"tags":[{"name":"ajax小思考","slug":"ajax小思考","permalink":"https://wzygene.github.io/tags/ajax小思考/"}]},{"title":"前后端数据交互的小思考","slug":"前后端数据交互的小思考","date":"2017-01-21T07:02:10.000Z","updated":"2017-10-09T03:08:34.585Z","comments":true,"path":"2017/01/21/前后端数据交互的小思考/","link":"","permalink":"https://wzygene.github.io/2017/01/21/前后端数据交互的小思考/","excerpt":"","text":"不知道从什么时候开始，WEB开发行业出现了前端和后端这两个概念。这两者的关系很符合马哲里面的对立统一思想。两拨人经常互相嘲讽，前端评价后端是“看数据库的”，后端说前段是“切图仔”。但是一个完整项目的产出，前端和后端都是必须的，而且必须去通力合作，才能完成好一个项目。 为什么说他们必须通力合作呢？他们又是怎么同理合作的呢？很通俗地解释一下这两个问题。 我们经常在网上浏览网站，所以我们都知道一个网站一般都是由很多的页面组成的。像一些电商类的网站页面怕是数万个都不止。试想一下，这些页面难道都是由前端工程师们一个一个地去写吗？开玩笑，累死也写不完。 其实这些页面虽然数量巨大，但是很多页面的结构基本都是一样的，比如一些商品展示的页面，页面结构基本上完全一样，不同的就是里面的商品以及他们的商品介绍（对工程师们来讲就是页面中的核心数据）。那么这些页面根本就没有必要一个一个去写，只要写好一个框架，把不同的数据渲染到页面中去就行了。 那么怎么渲染呢？ 像阿里，京东，腾讯，百度等。。。这样的巨无霸公司，数据量大到难以想象，他们的数据全都保存在世界上某个角落里的服务器上。有专门的设备给这些服务器降温，有专门的管理员进行维护。同时在各个企业内部，有很多后端工程师们在每天管理和使用着这些服务器上面的数据。他们的网站都要先从这些服务器上拿到数据，然后动态地渲染到前端工程师们做好的页面框架上。 那他们是怎么合作（前后端交互）的呢？ 思考这样一个问题，京东的服务器有很多，客户端也很多，这些服务器和客户端，几乎时时都在进行数据的交互，但是后端运行的是后端语言（Java、PHP、C#、python……），而前端运行的是前端的语言（JavaScript），他们的语法有很多的不同之处，怎么能让他们进行数据的交互呢？ 办法很简单，找一种前端和后端都认识，且都会处理的数据，作为媒介来进行数据交互。我们很自然地想到了字符串，所有的编程语言都有字符串这个类型的数据，也都有一些相应的方法对字符串进行不同方式的操作，更重要的是，字符串可以表达很多比较复杂的信息。所以字符换这种数据类型简直就是为了连接前后端而生的。 但是，字符串有一个致命的缺点，那就是它所代表的数据内部是杂乱无章的流式数据，没有结构可言。那么，像数组和对象这样的结构比较规整的数据类型，他就没有办法来传递了。怎么办呢? 办法总是比困难多的，其实很简单，既然字符串不能直接表示复杂的数据类型，那么我们给编程语言创造一种方法，用这种方法来使字符串可以携带复杂类型的数据不就行了吗？这个时候，XML这个玩意就诞生了。XML就是一种特定格式的字符串，这个字符串通过responseXML的方式从后端返回的结果是一个DOM树，DOM树的结构是很明确的，所以，我们解析一个DOM树的话，远比解析一个杂乱无章的字符串要简单的多。所以，XML基本上就解决了上面所提到的问题。 虽然XML格式数据可以描述和解析复杂的数据，但是解析过程比较复杂，还有XML存储数据的方式是用类似于html的标签进行包裹，所以，他的冗余字符(没有使用价值，仅仅是为了控制格式的字符)就比较多，整体显得比较笨重，最重要的是，解析一个DOM树需要进行大量的DOM操作，而这无疑会影响到浏览器的运行效率。所以，现在的互联网数据交互中，大多不会使用它，他多用在本地环境的一些操作中。至于互联网，效率(速度)是第一位的。所以，json这种更加轻量级的数据就成为了互联网数据交互操作的宠儿。 这样，前后端交互的基本问题就解决了。但是这只是基本的问题，还有很多性能和效率的问题依然在困扰着这个行业的从业者。在这样的前提下，流行框架出现了。MVVM、MVC框架很大程度上颠覆了了 WEB 领域的认知，它所表现出来的思想被很多人认为是“返璞归真”。 但事实是，这种思想确实将WEB开发推入了一个新的浪潮……","categories":[],"tags":[{"name":"ajax小思考","slug":"ajax小思考","permalink":"https://wzygene.github.io/tags/ajax小思考/"}]},{"title":"浅聊原型链原理","slug":"浅聊原型链原理","date":"2016-11-27T03:44:06.000Z","updated":"2017-10-09T03:08:44.969Z","comments":true,"path":"2016/11/27/浅聊原型链原理/","link":"","permalink":"https://wzygene.github.io/2016/11/27/浅聊原型链原理/","excerpt":"","text":"javascript作为世界上最好的脚本语言，几乎已经是无所不能。而想要触及这门语言的灵魂，我们必须要搞明白prototype，也就是原型，可以说原型是javascript最为核心的一个概念。 每一个构造函数都有一个属性prototype,指向一个对象。当这个构造函数被new的时候，他的每一个实例的proto属性也都指向这个对象。 每一个函数都天生都有一个prototype属性，指向一个空对象，也就是说，我们不需要定义这个属性，任何一个函数，在他写出来的那一瞬间，就有了这个属性，这个属性对于函数本身而言，没有任何的意义。它存在的意义，就是为他创造的实例对象做指向。通俗地说，构造函数就是一个伟大的母亲，她自身出现的那一刻，就为自己将来的儿子们准备好了一盏之路的明灯–prototype。 例如：有一个函数叫 People ，这个函数的属性 prototype 指向了一个对象，叫做 People.prototype。 一天，这个函数实例化了一个对象，叫做 Jacob， 实例化这个对象的时候，他就有了一个与生俱来的属性，叫做proto，他看见实例化自己的构造函数People的 prototype 属性指向了 People.prototype， 随之就将自己的proto属性也指向了 People.prototype 这个对象 123456function People(name,age) &#123; this.name = name; this.age = age;&#125;var Jacob = new People(&quot;Jacob&quot;,20); 当这个代码写完的时候，在浏览器内部其实就做了如下的事情： people.prototype是people构造函数的”原型”(prototype),是 Jacob 的”原型对象”(proto). 这是很多js书上的原文表达的意思，最简明扼要地解释了原型的根本内容。 原型就是这样了，那它到底是用来干是什么的呢？这就得提到原型链了。 说原型链，其实就是在解释proto这个玩意的作用，接着上面的例子来说，当Jacob身上没有某个属性的时候，它会沿着proto指向去People.prototype身上寻找这个属性。当原型对象People.prototype身上也没有，这个时候注意了，People.prototype也是一个对象，所以，它也有自己的proto，这样，Jacob就会继续沿着People.prototype的proto指向继续去寻找。当出现一下两种情况的时候才会停止： * 在某一时刻，他找到了它想要的那个属性； * 它走到的原型链的末端 Object.prototype 这个过程，就是一个原型链查找的过程，这个过程中所经历的每个原型对象组合在一起，就是一条原型链。 原型链查找的作用非常强大，可以说这个机制是构成javascript这门语言其他各种机制的根基，所以，我们必须要清清楚楚地搞清楚个机制，这对我们理解一些javascript库和之后继承机制有决定性的作用。","categories":[],"tags":[{"name":"JavaScript随笔","slug":"JavaScript随笔","permalink":"https://wzygene.github.io/tags/JavaScript随笔/"}]},{"title":"到底什么是构造函数","slug":"到底什么是构造函数","date":"2016-11-23T03:02:01.000Z","updated":"2017-10-09T03:08:30.784Z","comments":true,"path":"2016/11/23/到底什么是构造函数/","link":"","permalink":"https://wzygene.github.io/2016/11/23/到底什么是构造函数/","excerpt":"","text":"javascript是一门基于对象的语言，之所以是基于对象，而不是面向对象，是因为js这门语言没有类的概念，因此它的对象与基于类的语言中的对象有所不同。 我们可以把js中的对象想象成一组无序的散列表。比如下面这就是一个最简单的对象12345678var person = &#123; name:'小明', age:12, hobby:'王者农药', play:function()&#123; alert('来吧，我的亚瑟贼6！'); &#125;&#125; 在这个简单的对象里面定义了一个实体，他有自己的某些特征：name、age、hobby，这就是我们常说的属性，同时还有自己的一个行为：play王者农药，这就是我们常说的方法。 这是用字面量的方式创建的一个对象。我们还可以使用构造函数创建一个对象，但是构造函数是什么？如果仅仅将函数名首字母大写的函数理解为是构造函数。。。呵呵！ 要彻底理解构造函数，我们还是看看创建对象的演变过程吧，等这个故事讲完了，答案也就有了。 我们往往要创建大量的对象，而这些对象很多有相同的属性群和方法群，这样的对象要是全都用字面量的方式去创建，很麻烦，而且没必要，因为我们可以使用一个函数来模拟出一个工厂，专门用来创建一类对象，这就是所谓的工厂函数。请看下面的例子12345678910function createPerson(name,age,hobby)&#123; var person = &#123;&#125;; person.name = name; person.age = age; person.hobby = hobby; return person;&#125;var xiaoming = createPerson('xiaoming',12,'王者农药');var xiaohong = createPerson('xiaohong',14,'英雄联盟'); 使用这个函数，我们就可以创建一个 person 类型的对象，这个函数没别的功能，它只能：创建一个对象，赋予这个对象一定的属性，然后将这个对象返回。上述代码中， xiaoming 和xiaohong 就是用这个工程函数创建出来的两个有相同属性群的对象。 工程函数解决了创建多个相似对象的问题，但是它无法判定一个对象属于那种类型，这是个很麻烦的问题，但是随着js的发展，有一个新的模式出现了。那就是我们的主角：构造函数。先看一个构造函数的小例子1234567function Person(name,age,hobby)&#123; this.name = name, this.age = age, this.hobby = hobby&#125;var xiaoming = new Person('xiaoming',12,'王者农药');var xiaohong = new Person('xiaohong',14,'英雄联盟'); 上面这段代码就是典型的使用构造函数创建对象的过程。我们可以看到构造函数创建对象和工厂函数创建对象的几点不同之处： 1.函数体内部开始位置并没有创建对象； 2.直接将属性赋予了this对象； 3.函数结束的位置并没返回任何东西； 4.在调用函数的时候，在函数前面加了一个 new 操作符。 这几点不同之处就是理解构造函数的关键。 其实，一个函数能不能称之为构造函数，与它怎么定义没有半毛钱的关系，关键在于这个函数怎么调用。如果直接调用，或者作为一个对象的方法被调用，他都只是一个普通的函数。但是如果使用 new 操作符去调用一个函数，那就不一样了，这个 new 操作符会悄悄地做一些事情，而被调用的函数就是因为 new 操作符做的这些事情，被抬到了一个新的高度，然后被赋予一个新的称呼：构造函数。 那么，new 操作符到底做什么事情呢？其实就是4个步骤： 1.创建一个新对象； 2.将构造函数的上下文设置成这个对象（因此this就指向了这个对象）； 3.依次执行构造函数中的代码（也就是给这个对象添加属性）； 4.返回这个新对象。 所以，在 Person 函数中，我们没有看到创建对象，也没有看到函数返回任何东西，但是最终一个对象被创建了出来，就是因为这些工作都被 new 操作符隐式地完成了。 这个时候，我们别忘了之前的那个问题：怎么判断一个对象的类型？使用构造函数创建一个对象之后，这个对象就会有一个constructor属性，通过这个属性我们就能判断这个对象是什么类型了。在之前代码的基础上执行下面这句代码1console.log(xiaoming.constructor == Person); 没什么好怀疑的，打印的结果就是 true。 我们现在该思考一个问题了，构造函数中并没有给this对象赋值一个 constructor 的属性啊，它是从哪跑粗来的？ 答案是：原型。 原型是什么？呵呵，荆轲刺秦王！！！","categories":[],"tags":[{"name":"JavaScript随笔","slug":"JavaScript随笔","permalink":"https://wzygene.github.io/tags/JavaScript随笔/"}]},{"title":"浅拷贝和深拷贝","slug":"浅拷贝和深拷贝","date":"2016-11-19T02:17:42.000Z","updated":"2017-10-09T03:08:41.648Z","comments":true,"path":"2016/11/19/浅拷贝和深拷贝/","link":"","permalink":"https://wzygene.github.io/2016/11/19/浅拷贝和深拷贝/","excerpt":"","text":"javascript 语言中的数据类型分为简单数据类型和复杂数据类型。其中简单数据类型有：1Number,String,Boolean,Null,Undefined 复杂数据类型有：1Object 简单数据类型的赋值是数据副本的直接拷贝，而复杂数据类型的赋值只是将数据在堆内存的指针赋值给一个变量。这些内容详见这篇博文：数据类型及内存 这样就会导致一个问题，就是将对象1赋值给对象2之后，对象2的任何操作最终都会反映到对象1中。比如，看下边这个例子：12345678910111213141516var obj1 = &#123; foo: 'bar', a: 1, b: [1, 2, 3], c: &#123; arr: [1,2,3] &#125;&#125;;var obj2 = obj1;obj2.c.arr.push('abc');obj2.d = true;console.log(obj2);console.log(obj1); console.log(obj1 === obj2); 代码的执行结果是: 很明显，obj2 的所有操作都改变了 obj1（实际上，他们本来就是同一个对象）。 但是我们现在有一个需求：将obj1中的数据拷贝一份到obj2 中去，而两个对象互不影响。 这个时候，要想使两个对象之间互不影响，需要遍历对象，从内部拷贝数据，看下边这段代码：12345678910111213141516var obj1 = &#123; foo: 'bar', a: 1, b: [1, 2, 3], c: &#123; arr: [1,2,3] &#125;&#125;;for (var key in obj1) &#123; obj2[key] = obj1[key];&#125;obj2.c.arr.push('abc');obj2.d = true;console.log(obj2);console.log(obj1); console.log(obj1 === obj2); 这段代码执行结果是: 我们可以看到，obj1 和 obj2 不相同了，并且给 obj2 新增的 d 属性，并没有反映到 obj1 中去。但是，给 obj2 属性 c 中数据 添加的新元素 ‘abc’ 还是出现在了 obj1 中 。 因为， 我们上边进行的操作属于浅拷贝，只能保证对象中的简单数据类型互不干扰，但是对象中不可避免地会出现一些复杂的数据类型，这个时候，浅拷贝是无法满足对象之间互不影响的需求的。这个时候，就要进行深拷贝。 有一种方式可以很简单地实现深拷贝：利用 json 对象的方法，先将要被拷贝的对象转化为字符串，然后再将该字符串转换回对象的格式，然后赋值给另一个变量，就实现了深拷贝。看下边这段代码:123456789101112131415var obj1 = &#123; foo: 'bar', a: 1, b: [1,2,3], c: &#123; foo: 'baz' &#125;&#125;;var obj2 = JSON.parse(JSON.stringify(obj1));obj2.d = true;obj2.c['zhangsan'] = 'lisi';console.log(obj1);console.log(obj2);console.log(obj1 === obj2); 这段代码的执行结果是： 我们看到，obj2 对象的 c 属性本身也是一个对象，给这个对象添加了属性 zhangsan 之后，并没有反映到 obj1 对象中去，也就是说，我们已经实现了深拷贝。为什么这种方式可以实现深拷贝呢？ 因为json字符串转换为对象的时候，会自己去构建新的内存地址存放数据 但是这种方法还是存在一个问题：在IE8浏览器上不支持。所以，想要兼容 IE8 浏览器的话，我们要转换思路，用一种更加朴素的方式实现深拷贝–递归。这种思想的本质就是：在浅拷贝的基础上进行判断，然后根据判断的结果利用递归的思想进行拷贝，这也就是浅拷贝的加强版。 看下边这段代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var obj1 = &#123; foo: 'bar', a: 1, b: [1,2,3], c: &#123; foo: 'bar' &#125;&#125;;// 封装函数，用来判断参数是不是数组类型function isArray(params) &#123; return Object.prototype.toString.call(params) === '[object Array]';&#125;// 封装函数，用来判断参数是不是对象类型function isObject(params) &#123; return Object.prototype.toString.call(params) === '[object Object]';&#125;// 封装一个函数，其功能就是实现深拷贝function extent(target,source) &#123; // 循环遍历被拷贝的对象 for (var key in source) &#123; // 判断对象的元素是不是数组类型的 if(isArray(source[key]))&#123; // 是，递归调用函数 target[key] = []; extent(target[key],source[key]); &#125; // 判断对象的元素是不是对象类型的 else if(isObject(source[key])) &#123; // 是，递归调用函数 target[key] = &#123;&#125;; extent(target[key],source[key]); &#125; // 都不是的话，该数据类型就是一个简单数据类型，直接拷贝就可以了 else &#123; target[key] = source[key]; &#125; &#125;&#125;var obj2 = &#123;&#125;;extent(obj2,obj1);obj2.d = true;obj2['b'].push(4);obj2.c.zhangsan = 'lisi';console.log(obj1);console.log(obj2);console.log(obj1 === obj2); 代码打印的结果是： 结果证明，我们以一种极其朴素的方式实现了深拷贝。 需要注意的是，递归是一种非常损耗性的的操作，如果对象比较复杂，层级也比较多，递归实现深拷贝会带来性能上的问题。在遇到需要采用深拷贝的场景时，要根据具体的需求和应用场景，选择最合适的方法。在实际的应用场景中，也是浅复制更为常用。","categories":[],"tags":[{"name":"JavaScript随笔","slug":"JavaScript随笔","permalink":"https://wzygene.github.io/tags/JavaScript随笔/"}]},{"title":"JavaScript函数上下文--this指向","slug":"JavaScript函数上下文-this指向","date":"2016-10-28T12:26:32.000Z","updated":"2017-10-10T12:54:59.662Z","comments":true,"path":"2016/10/28/JavaScript函数上下文-this指向/","link":"","permalink":"https://wzygene.github.io/2016/10/28/JavaScript函数上下文-this指向/","excerpt":"","text":"JavaScript 中的函数上下文，也就是 this 的指向一直是这门语言很令人头疼的一个内容，不同环境下使用 this 经常会被搞得头晕眼花。 首先，要对 this 有一个整体的认识： 一个函数不调用的话，根本就不知道他的 this 是谁，因为它根本就没有 this。也就是说，一个函数的 this 取决于它被谁调用，跟它写在哪,长什么样压根没有关系。 简言之：函数上下文是函数调用的时候表现出来的性质，而不是函数定义的时候写死的性质。 基本的规律可以大致分为一下五点 1. 函数用圆括号调用，函数的上下文是window对象所有的全局变量都是 window 对象的属性，而函数里面的变量，它不是函数的属性，不是任何对象的属性，他就只是一个变量。 2. 函数如果作为一个对象的方法被对象打点调用，那么这个函数的上下文就是这个对象3. 函数是事件处理函数，函数的上下文就是触发这个事件的DOM元素4. 定时器调用函数，上下文是window对象5. 数组中存放的函数被数组索引调用,this就是这个数组","categories":[],"tags":[{"name":"JavaScript随笔","slug":"JavaScript随笔","permalink":"https://wzygene.github.io/tags/JavaScript随笔/"}]},{"title":"JavaScript中的定时器","slug":"JavaScript中的定时器","date":"2016-10-09T11:22:36.000Z","updated":"2017-10-09T11:58:25.080Z","comments":true,"path":"2016/10/09/JavaScript中的定时器/","link":"","permalink":"https://wzygene.github.io/2016/10/09/JavaScript中的定时器/","excerpt":"","text":"我们都很熟悉，JavaScript中有两种定时器：间歇调用定时器（setInterval）和超时调用定时器（setTimeout）。它们都接受两个参数：第一个参数是回调函数（也可以是一个包含JS格式代码的字符串），第二个参数表示毫秒数。前者是每隔一定的时间就会触发一次，后者则是页面刷新之后超过一定的时间会触发一次，之后不再触发。 但是有的时候，经过定时器第二个参数所设定的时间，函数还是没有执行。 主要的原因是：JavaScript是单线程语言，因此一定时间内只能执行一段代码，而JS程序中的异步事件会被强迫安排在一个JavaScript的任务队列中，等待执行，定时器中的第二个参数会告诉JavaScript再过多长时间把当前任务添加到队列中，队列是空的，那么添加的代码会立即执行，但是如果它前面有别的代码在排队的话，必须等前面的代码执行完之后，自己才能执行。这个队列是保存在全局的。 了解了这个机制之后，之前很疑惑的两个问题也就迎刃而解了： 为什么定时器中的 this 指的都是 window 对象呢？ 为什么定时器的第二个参数设置成 0 之后，还是会在最后执行？ 第一个问题：无论定时器在哪个函数作用域中，作为它第一个参数的回调函数都会被强制安排到window全局的一个JS任务队列中，所以函数上下文（this的指向）自然就指向了window对象。 第二个问题：异步事件所处的那个JS队列除了在全局作用域下，还有一个特点，就是会等所有的代码执行完了之后，这个队列里的代码才会执行，所以，不管定时器的第二个参数设置为多少，定时器里的的代码都是在最后才会执行。","categories":[],"tags":[{"name":"JavaScript随笔","slug":"JavaScript随笔","permalink":"https://wzygene.github.io/tags/JavaScript随笔/"}]},{"title":"网站开发的两种模式：渐进增强与优雅降级","slug":"网站开发的两种模式：渐进增强与优雅降级","date":"2016-09-16T02:57:52.000Z","updated":"2017-10-01T09:28:47.422Z","comments":true,"path":"2016/09/16/网站开发的两种模式：渐进增强与优雅降级/","link":"","permalink":"https://wzygene.github.io/2016/09/16/网站开发的两种模式：渐进增强与优雅降级/","excerpt":"","text":"因为历史遗留的很多问题，直到现在，浏览器兼容问题仍然是前端开发从业者不能忽视的一个问题。现在异常火爆的移动端，CSS3写的飞起。兼容性已经不是主要问题了。但是在PC端，兼容性主要还是跟IE很多的低版本浏览器较劲。我们不能告诉用户，扔掉你的IE，换个别的浏览器，我们只能从自身出发，尽量让我们的产品能够在各种浏览器中都能正常地跑起来。 HTML5和CSS3这两种新标准的发布，为前端开发开辟了全新的，广阔的空间，但是也带来了更加严峻的兼容性问题。很多的新特性在低版本浏览器不能兼容，但是这些新特性实在太过优秀，放弃实在可惜。所以就出现了两种解决问题的方案：渐进增强和优雅降级。 渐进增强： 优雅降级： 这两张图很形象地表达出了两种开发模式的思想。 两种开发模式的大致思路是： 渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。 优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。 渐进增强 观点：项目开发一开始应关注于内容本身。内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得渐进增强成为一种更为合理的设计范例。这也是它立即被Yahoo所采纳并用以构建其分级式浏览(Graded Browser Support)策略的原因所在。 优雅降级观点：项目开发的开始阶段应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。 如何抉择如果软件开发的预算和时间充足，就不存在抉择的问题。然而现实很残酷，要么开发周期短，要么开发预算少，或者二者兼而有之，这个时候该如何抉择？ 根据你的用户所使用的客户端的版本来做决定。因为渐进增强和优雅降级的概念本质上是软件开发过程中低版本软件与高版本软件面对新功能的兼容抉择问题。服务端程序很少存在这种问题，因为开发者可以控制服务端运行程序的版本，就无所谓渐进增强和优雅降级的问题。但是客户端程序则不是开发者所能控制的。我们所谓的客户端，可以指浏览器，移动终端设备（如：手机，平板电脑，智能手表等）以及它们对应的应用程序（浏览器对应的是网站，移动终端设备对应的是相应的APP）。 现在有很成熟的技术，能够让你分析使用你客户端程序的版本比例。如果低版本用户居多，当然优先采用渐进增强的开发流程；如果高版本用户居多，为了提高大多数用户的使用体验，那当然优先采用优雅降级的开发流程。 然而事实情况是怎么样的呢？绝大多数的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。例如：新浪微博网站前端的更新，拥有这种亿级用户的网站，绝对不可能追求某个特效而不考虑低版本用户可不可用，一定是确保低版本到高版本的可访问性，再去渐进增强，采用新功能给高版本用户提供更好的用户体验。但也不是没有反例。如果你开发的是一款面向青少年的软件（或网站），你知道这个群体的人总是喜欢尝试新事物，总是喜欢酷炫的特效，总是喜欢把它们的软件更新到最新版本（而不像我们老一辈的用户）。面对这种情况，渐进增强的开发流程实为上选。","categories":[],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"https://wzygene.github.io/tags/前端开发/"}]},{"title":"JavaScript中DOM节点的创建、插入、删除、复制、查找","slug":"JavaScript中DOM节点的创建、插入、删除、复制、查找","date":"2016-08-09T06:04:17.000Z","updated":"2017-10-09T11:21:33.439Z","comments":true,"path":"2016/08/09/JavaScript中DOM节点的创建、插入、删除、复制、查找/","link":"","permalink":"https://wzygene.github.io/2016/08/09/JavaScript中DOM节点的创建、插入、删除、复制、查找/","excerpt":"","text":"JavaScript 作为前端开发工作的核心，其很重要的一环就是进行DOM操作，而DOM操作的基础就是DOM节点的创建、插入、删除、复制、查找等工作。 一 创建节点、追加节点 createElement(标签名) 创建一个元素节点（具体的一个元素） createTextNode(节点文本内容) 创建一个文本节点 createDocumentFragment() 创建一个DOM片段 appendChild(节点) 追加一个节点 二 插入节点 appendChild(节点) 这也是一种插入节点的方式，还可以添加已经存在的元素，会将其元素从原来的位置移到新的位置 insertBefore(a,b) 是参照节点，意思是a节点会插入大b节点的前面 三 删除、移除节点 removeChild(节点) 删除一个节点，用于移除一个参数（节点）。返回值是被移除的节点，被移除的节点仍在文档中，只是文档中已经没有其位置了 四 赋值节点 cloneNode() 用于赋值节点，接受一个布尔值作为参数，true表示深复制（复制节点及其所有子节点），false表示浅复制（复制节点本身，不复制子节点） 五 替换节点 replaceChild（a，b） 用于替换节点，接受两个参数，第一个参数是要插入的节点，第二个是被替换的节点。返回值是被替换的节点 六 查找节点 getElementsByTagName(标签) 通过标签名获取元素 getElementsByName(name) 通过元素的name属性获取元素 getElementById(id) 通过元素的id属性获取元素","categories":[],"tags":[{"name":"DOM禅意花园","slug":"DOM禅意花园","permalink":"https://wzygene.github.io/tags/DOM禅意花园/"}]},{"title":"js作用域浅析之闭包","slug":"js作用域浅析之闭包","date":"2016-07-06T02:33:49.000Z","updated":"2017-10-10T12:57:22.070Z","comments":true,"path":"2016/07/06/js作用域浅析之闭包/","link":"","permalink":"https://wzygene.github.io/2016/07/06/js作用域浅析之闭包/","excerpt":"","text":"什么是闭包？先来写一个最简单的闭包123456(function()&#123; var a = 'hello'; function foo()&#123; console.log(a); &#125;&#125;)() 这就是一个闭包： 函数 和 函数内部能访问到的变量（也叫环境）的总和，就是一个闭包 很多人会觉得：是不是少了 return foo 啊？确实，我们经常看到的闭包函数最终都会返回一个函数的。就像这样： 1234567(function()&#123; var a = 'hello'; function foo()&#123; console.log(a); &#125; return foo;&#125;)() 但是，我们是不是应该想一想为什么要返回foo啊？ 其实答案很简单，因为如果不 return，你就无法使用这个闭包。把 return foo 改成 window.bar = bar 也是一样的，只要让外面可以访问到这个 foo 函数就行了。 所以 return foo 只是为了 foo 能被使用，也跟闭包无关。 还有一个问题：为什么要函数套函数呢？这里就要了解 JavaScript 的作用域了。JS中是没有块作用域的，它只有全局作用域和函数作用域。这里是因为需要局部变量，所以才把 a 放在一个函数里，如果不把 a 放在一个函数里，local 就是一个全局变量了，达不到使用闭包的目的——隐藏变量。 有些人看到闭包这个名字，就一定觉得要用什么包起来才行。其实这是翻译问题，闭包的原文是 Closure，跟包没有任何关系。 所以函数套函数只是为了造出一个封闭的作用域，用来存放不想被外界肆意访问的变量，跟闭包无关。 闭包的作用是什么其实，上边已经提到了它的主要作用：隐藏变量。 假设我们在做一个游戏，在写其中关于还剩几条命的代码。如果不用闭包，你可以直接用一个全局变量： 1window.lives = 30 // 还有三十条命 这样看起来很不妥。万一不小心把这个值改成 -1 了怎么办。所以我们不能让别人直接访问这个变量。怎么办呢？ 用局部变量！！！ 但是用局部变量别人又访问不到，怎么办呢？ 暴露一个访问器（函数），让别人可以间接访问。 代码如下： 123456789101112function()&#123; var lives = 50 window.奖励一条命 = function()&#123; lives += 1 &#125; window.死一条命 = function()&#123; lives -= 1 &#125;&#125;() 那么在其他的 JS 文件，就可以使用 window.奖励一条命() 来涨命，使用 window.死一条命() 来让角色掉一条命。 为什么题目叫做“js作用域浅析之闭包”？其实，闭包本身就是 JS 函数作用域的副产品。 换句话说，正是由于 JS 的函数内部可以使用函数外部的变量，所以这段代码正好符合了闭包的定义。而不是 JS 故意要使用闭包。 只要你懂了 JS 的作用域，你自然而然就懂了闭包，即使你不知道那就是闭包！ 关于闭包的谣言闭包会造成内存泄露？ 错。 内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。 闭包里面的变量明明就是我们需要的变量（lives），凭什么说是内存泄露？ 这个谣言是如何来的？ 因为 IE。IE 有 bug，IE 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。 这是 IE 的问题，不是闭包的问题。","categories":[],"tags":[{"name":"JavaScript随笔","slug":"JavaScript随笔","permalink":"https://wzygene.github.io/tags/JavaScript随笔/"}]},{"title":"函数执行环境及变量作用域","slug":"函数执行环境及变量作用域","date":"2016-06-28T12:12:14.000Z","updated":"2017-10-09T03:08:27.049Z","comments":true,"path":"2016/06/28/函数执行环境及变量作用域/","link":"","permalink":"https://wzygene.github.io/2016/06/28/函数执行环境及变量作用域/","excerpt":"","text":"执行环境是javascript中最为重要的一个概念。执行环境定义了变量或者函数有权访问的其他数据，决定了他们各自的行为。 在每一种编程语言中，都有所谓的执行环境的概念，但是很少有人重视这个概念，因为每个程序员都对执行环境都有自己感性的认识：自己内部的数据和外部的全局变量都是可以使用的。 这么理解在大多数时间内是没有太大问题的。但是要想深入理解这门语言，应该对这个概念有更加清晰的认识，做到知其然，并知其所以然。 每一个执行环境中都有一个变量对象，这个对象里边存放了当前环境中所有的变量和方法。 最外层的执行环境，也叫全局执行环境，通俗一点说，在浏览器中，就是我们常常说的window对象，因此全局环境中所有的变量和函数都是作为window对象的属性和方法而存在的。 每一个函数都是一个独立的执行环境。js语言有一个管理执行环境的机制：当程序执行到一个函数时，这个函数将被推进一个环境栈中，等到函数执行结束的时候，环境栈会将这个函数弹出，并删除这个函数的便能量对象，然后将环境栈的控制权交还给之前的执行环境。而window对象会直到应用程序退出（例如关闭网页或者浏览器）的时候才被删除数据。 当代码在一个环境中执行的时候，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境能够访问的变量和函数进行有序的访问。作用域链的第一个变量对象，就是当前执行环境的变量对象。作用域链中的下一个变量对象来自外部环境，而再下一个变量对象来自下一个外部环境。就这样，一直延伸到全局环境中。所以，全局环境的变量对象是每个作用域链的最后一个对象。 标识符解析是沿着作用域链一级一级地搜索标识符的过程。 这个解析的过程始终都是从第一个变量对象开始，逐级向外延伸，直到找到标识符为止（如果找到最后还没有找到，那就会报错）。下边代码是一个三级作用域链的小例子：1234567var Country = 'China';function province()&#123; var province = 'beijing'; function county ()&#123; var county = 'changping'; &#125;&#125; 在上变的代码中： + 函数 county 中，能访问到 county，province，Country 这三个变量； + 函数 province 中，能访问到 province，Country 这两个变量； + 在全局中，只能访问到 Country 这一个变量。 函数的作用域链如下图： 作用域链的箭头经过的地方，都是该函数的有效作用域，且查找顺序和作用域链经过的区域顺序一致。 这里有一点需要注意一下：函数参数也当做变量来对待，因此访问规则与执行环境中其他变量相同。","categories":[],"tags":[{"name":"JavaScript随笔","slug":"JavaScript随笔","permalink":"https://wzygene.github.io/tags/JavaScript随笔/"}]},{"title":"js数据类型及内存","slug":"js数据类型及内存","date":"2016-06-11T13:38:46.000Z","updated":"2017-10-09T03:09:07.649Z","comments":true,"path":"2016/06/11/js数据类型及内存/","link":"","permalink":"https://wzygene.github.io/2016/06/11/js数据类型及内存/","excerpt":"","text":"与很多其他的语言不同，JavaScript 是一门弱类型的语言，所以的它的变量类型很少，大体上只分为：基本数据类型和引用数据类型。 其中，基本数据类型包括：Number,String,Boolean,Undefined,null。引用数据类型有：Object（Array也属于Object）。 基本数据类型存放在栈内存中，引用数据类型保存在堆内存中。 到底有什么区别呢？看下边这段小代码： 123456789101112131415161718192021222324var num1 = 998;var num2 = num1;var str1 = 'foo';var str2 = str1;var arr1 = ['a','b','c'];var arr2 = arr1;var obj1 = &#123; ele1: 'baz', ele2: 'bar'&#125;;var obj2 = obj1;num2 = 1000;str2 = 'zhangsan';arr2.push('d');obj2.ele3 = 'bee';console.log(num1,num2);console.log(str1,str2);console.log(arr1,arr2);console.log(obj1,obj2); 打印结果是： 可以看到，num2 和 str2 的修改并没有影响到 num1 和 str1，但是 arr2 和 obj2，修改后，arr1 和 obj1 也随之变化了。造成这种现象的原因就是两种数据在不同的内存中存储。 当上述代码执行到第14行的时候，内存中的情况是这样的： 从这个图中，我们可以看到，基本数据类型是直接存放在栈内存中的，将一个变量的值赋给另一个变量的时候，都是将栈中的值直接拷贝一份，赋值给另一个变量。也就是说，另一个变量被赋值之后，就和原来的变量没有任何关系了，它自己如何改动当然都不会影响到原来的变量。 但是引用数据类型的内容是存放在堆内存中的，而存储在栈内存中的只是一个指向堆内存中数据的指针（地址）。引用数据类型赋值的时候，也是将栈内存中的数据拷贝一份，赋值给另一个变量。这样，被赋值的元素得到的也是一个指针，结果就是，赋值与被赋值的两个元素都指向了同一块堆内存。所以，两个对象中任何一个针对对象做的操作都会反映到另一个身上（其实他们压根就是同一个对象）。 上面的代码执行完之后的结果如下： 这就是最终的上面打印结果的原因。","categories":[],"tags":[{"name":"JavaScript随笔","slug":"JavaScript随笔","permalink":"https://wzygene.github.io/tags/JavaScript随笔/"}]},{"title":"with函数--一个不错的小工具","slug":"with函数-一个不错的小工具","date":"2016-03-18T08:32:15.000Z","updated":"2017-10-09T03:09:15.616Z","comments":true,"path":"2016/03/18/with函数-一个不错的小工具/","link":"","permalink":"https://wzygene.github.io/2016/03/18/with函数-一个不错的小工具/","excerpt":"","text":"with函数，也叫做with语句。是一个拓展作用域链的小工具。他可以通过传递 “参数” 的方式，简化我们的代码量。请看下边的例子：12345678910var date = new Date();function getDate() &#123; var year = date.getFullYear(); var month = date.getMonth()+1; var day = date.getDate(); return year+' '+month+' '+day;&#125;var currentDate = getDate();console.log(currentDate); 上面的这段代码的，首先通过构造函数的方式创建了一个日期对象，然后定义了一个函数，在函数中分别获取了当前的年、月、日，最后将它们拼接成一个字符串并返回。 可以看到，我们在函数getDate中，每次获取年月日，都要通过事先创建的日期对象来调用其内部方法来实现。这是因为直接调用方法的话，在当前的作用域链中找不到对应的方法。 但是，通过with函数就可以避免频繁使用对象，我们可将对象作为参数传到with函数中去，从而扩展作用域链（将date对象加入到自己的作用域链中），然后就可以直接调用方法了。改进的代码如下：1234567891011var date = new Date();function getDate() &#123; with(date)&#123; var year = getFullYear(); var month = getMonth()+1; var day = getDate(); &#125; return year+' '+month+' '+day;&#125;var currentDate = getDate();console.log(currentDate); 这段代码和上面那段代码，最终的执行结果是一样的。","categories":[],"tags":[{"name":"JavaScript随笔","slug":"JavaScript随笔","permalink":"https://wzygene.github.io/tags/JavaScript随笔/"}]}]}