{"meta":{"title":"原始计划","subtitle":"黎明之前...","description":"生活从来不欺骗任何一个人,因为它根本谁都不认识.","author":"wzygene","url":"https://wzygene.github.io"},"pages":[],"posts":[{"title":"到底什么是构造函数","slug":"到底什么是构造函数","date":"2017-08-28T03:02:01.000Z","updated":"2017-08-28T03:02:01.433Z","comments":true,"path":"2017/08/28/到底什么是构造函数/","link":"","permalink":"https://wzygene.github.io/2017/08/28/到底什么是构造函数/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"浅聊原型链原理","slug":"浅聊原型链原理","date":"2015-11-27T03:44:06.000Z","updated":"2017-08-28T03:05:49.217Z","comments":true,"path":"2015/11/27/浅聊原型链原理/","link":"","permalink":"https://wzygene.github.io/2015/11/27/浅聊原型链原理/","excerpt":"","text":"javascript作为世界上最好的脚本语言，几乎已经是无所不能。而想要触及这门语言的灵魂，我们必须要搞明白prototype，也就是原型，可以说原型是javascript最为核心的一个概念。 每一个构造函数都有一个属性prototype,指向一个对象。当这个构造函数被new的时候，他的每一个实例的proto属性也都指向这个对象。 每一个函数都天生都有一个prototype属性，指向一个空对象，也就是说，我们不需要定义这个属性，任何一个函数，在他写出来的那一瞬间，就有了这个属性，这个属性对于函数本身而言，没有任何的意义。它存在的意义，就是为他创造的实例对象做指向。通俗地说，构造函数就是一个伟大的母亲，她自身出现的那一刻，就为自己将来的儿子们准备好了一盏之路的明灯–prototype。 例如：有一个函数叫 People ，这个函数的属性 prototype 指向了一个对象，叫做 People.prototype。 一天，这个函数实例化了一个对象，叫做 Jacob， 实例化这个对象的时候，他就有了一个与生俱来的属性，叫做proto，他看见实例化自己的构造函数People的 prototype 属性指向了 People.prototype， 随之就将自己的proto属性也指向了 People.prototype 这个对象 123456function People(name,age) &#123; this.name = name; this.age = age;&#125;var Jacob = new People(&quot;Jacob&quot;,20); 当这个代码写完的时候，在浏览器内部其实就做了如下的事情： people.prototype是people构造函数的”原型”(prototype),是 Jacob 的”原型对象”(proto). 这是很多js书上的原文表达的意思，最简明扼要地解释了原型的根本内容。 原型就是这样了，那它到底是用来干是什么的呢？这就得提到原型链了。 说原型链，其实就是在解释proto这个玩意的作用，接着上面的例子来说，当Jacob身上没有某个属性的时候，它会沿着proto指向去People.prototype身上寻找这个属性。当原型对象People.prototype身上也没有，这个时候注意了，People.prototype也是一个对象，所以，它也有自己的proto，这样，Jacob就会继续沿着People.prototype的proto指向继续去寻找。当出现一下两种情况的时候才会停止： * 在某一时刻，他找到了它想要的那个属性； * 它走到的原型链的末端 Object.prototype 这个过程，就是一个原型链查找的过程，这个过程中所经历的每个原型对象组合在一起，就是一条原型链。 原型链查找的作用非常强大，可以说这个机制是构成javascript这门语言其他各种机制的根基，所以，我们必须要清清楚楚地搞清楚个机制，这对我们理解一些javascript库和之后继承机制有决定性的作用。","categories":[],"tags":[]},{"title":"函数执行环境及变量作用域","slug":"函数执行环境及变量作用域","date":"2015-06-28T12:12:14.000Z","updated":"2017-08-28T12:17:18.289Z","comments":true,"path":"2015/06/28/函数执行环境及变量作用域/","link":"","permalink":"https://wzygene.github.io/2015/06/28/函数执行环境及变量作用域/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"with函数--一个不错的小工具","slug":"with函数-一个不错的小工具","date":"2015-06-18T08:32:15.000Z","updated":"2017-08-28T13:50:08.920Z","comments":true,"path":"2015/06/18/with函数-一个不错的小工具/","link":"","permalink":"https://wzygene.github.io/2015/06/18/with函数-一个不错的小工具/","excerpt":"","text":"with函数，也叫做with语句。是一个拓展作用域链的小工具。他可以通过传递 “参数” 的方式，简化我们的代码量。请看下边的例子：12345678910var date = new Date();function getDate() &#123; var year = date.getFullYear(); var month = date.getMonth()+1; var day = date.getDate(); return year+' '+month+' '+day;&#125;var currentDate = getDate();console.log(currentDate); 上面的这段代码的，首先通过构造函数的方式创建了一个日期对象，然后定义了一个函数，在函数中分别获取了当前的年、月、日，最后将它们拼接成一个字符串并返回。 可以看到，我们在函数getDate中，每次获取年月日，都要通过事先创建的日期对象来调用其内部方法来实现。这是因为直接调用方法的话，在当前的作用域链中找不到对应的方法。 但是，通过with函数就可以避免频繁使用对象，我们可将对象作为参数传到with函数中去，从而扩展作用域链（将date对象加入到自己的作用域链中），然后就可以直接调用方法了。改进的代码如下：1234567891011var date = new Date();function getDate() &#123; with(date)&#123; var year = getFullYear(); var month = getMonth()+1; var day = getDate(); &#125; return year+' '+month+' '+day;&#125;var currentDate = getDate();console.log(currentDate); 这段代码和上面那段代码，最终的执行结果是一样的。","categories":[],"tags":[]}]}